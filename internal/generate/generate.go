package generate

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/pkg/errors"
)

type CodeGenerator interface {
	// Name returns a unique identifier for an instance of
	// generation. Name contributes to part of the generated
	// filename. Each invocation of `//go:generate` within a
	// file must return a different result from Name. Name
	// may return the empty string.
	Name() string

	// Template returns the template used to generate the
	// output file. A Go `package` expression for the package
	// of the file invoking `//go:generate` will automatically
	// be prepended to the template's output along with a
	// comment identifying the file as generated.
	Template() *template.Template

	// Data returns the value passed as the `data` param into
	// the template.Template.Execute() method.
	Data() interface{}
}

var (
	file string
	pkg  string
)

// Generate populates the provided input, executes
// the template provided by the CodeGenerator, and writes
// the template's output to the filename provided
// by the CodeGenerator.
func Generate(gen CodeGenerator, inputs []Input) {
	defer debug()
	setup(append(inputs,
		Input{Type: EnvVar, Dst: &file, Key: "GOFILE"},
		Input{Type: EnvVar, Dst: &pkg, Key: "GOPACKAGE"}))
	write(generate(gen))
}

func debug() {
	if err := recover(); err != nil {
		fmt.Printf("FAIL: %s/%s\n", workingDir(), file)
		fmt.Println(command())
		fmt.Println()
		fmt.Println(err)
		os.Exit(1)
	}
}

func setup(inputs []Input) {
	for _, in := range inputs {
		in.setup()
	}
	flag.Parse()
	for _, in := range inputs {
		in.valid()
	}
}

func generate(gen CodeGenerator) (string, string) {
	var output bytes.Buffer
	if err := gen.Template().Execute(&output, gen.Data()); err != nil {
		panic(fmt.Errorf("failed to generate code: %w", err))
	}
	generated := append(prefix(), output.Bytes()...)
	formatted, err := format.Source(generated)
	if err != nil {
		panic(fmt.Errorf("failed to format the following code: ```\n%s\n```: %w",
			strings.TrimSpace(string(generated)), err))
	}
	return filename(gen.Name()), string(formatted)
}

func write(filename, output string) {
	file, err := os.Create(filename)
	if err != nil {
		panic(fmt.Errorf("failed to open output file: %w", err))
	}
	defer func() {
		err := file.Close()
		if err != nil {
			panic(fmt.Errorf("failed to close output file: %w", err))
		}
	}()

	_, err = fmt.Fprintln(file, output)
	if err != nil {
		panic(fmt.Errorf("failed to print output: %w", err))
	}
}

func filename(name string) string {
	noExt := file[0 : len(file)-len(filepath.Ext(file))]
	if len(name) > 0 {
		return fmt.Sprintf("%s_%s.g.go", noExt, strings.ToLower(name))
	}
	return fmt.Sprintf("%s.g.go", noExt)
}

func prefix() []byte {
	return []byte(fmt.Sprintf("// Code generated by %s. DO NOT EDIT.\npackage %s\n", command(), pkg))
}

func workingDir() string {
	dir, err := os.Getwd()
	if err != nil {
		panic(errors.Wrap(err, "failed to get working directory"))
	}
	return dir
}

func command() string {
	// Get rid of the path to the executable.
	cmd := os.Args[0]
	i := strings.LastIndexByte(cmd, '/')
	cmd = cmd[i+1:]

	// Join the executable's filename with the rest of the args.
	return strings.Join(append([]string{cmd}, os.Args[1:]...), " ")
}

type InputType int

const (
	Flag InputType = iota
	EnvVar
)

// Input defines a CLI flag or environment
// variable used as input to a code generator.
// An Input is usually used to populate a
// field of a struct implementing the
// CodeGenerator interface.
type Input struct {
	Type InputType

	// The where to store the input's value.
	Dst *string

	// Either the name of the flag or the name
	// of the environment variable.
	Key string
}

func (x Input) setup() {
	switch x.Type {
	case Flag:
		flag.StringVar(x.Dst, x.Key, "", "")

	case EnvVar:
		val, exists := os.LookupEnv(x.Key)
		if !exists {
			panic(fmt.Errorf("$%s undefined", x.Key))
		}
		*x.Dst = val

	default:
		panic(fmt.Errorf("unknown input type '%v'", x.Type))
	}
}

func (x Input) valid() {
	if len(*x.Dst) > 0 {
		return
	}

	switch x.Type {
	case Flag:
		panic(fmt.Errorf("%s flag is empty", x.Key))

	case EnvVar:
		panic(fmt.Errorf("$%s is empty", x.Key))

	default:
		panic(fmt.Errorf("unknown input type '%v'", x.Type))
	}
}
